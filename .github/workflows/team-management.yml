# SPDX-FileCopyrightText: Copyright (c) 2025 Broadsage <opensource@broadsage.com>
#
# SPDX-License-Identifier: Apache-2.0

---
name: "[Support] Team Management and Reporting"

on:
  issues:
    types: [labeled] # Only run when labels are added, not on open
  pull_request:
    types: [labeled, review_requested] # Only run when labels added or reviews requested
  schedule:
    # Generate weekly reports every Monday at 9 AM UTC
    - cron: "0 9 * * 1"
  workflow_dispatch:
    inputs:
      action_type:
        description: "Type of action to run"
        required: false
        default: "both"
        type: choice
        options:
          - "assignment"
          - "reporting"
          - "both"
      report_type:
        description: "Type of report to generate"
        required: false
        type: choice
        options:
          - "weekly"
          - "monthly"
          - "custom"
        default: "weekly"

# Use restrictive default permissions
permissions:
  contents: read

jobs:
  # Team assignment based on labels
  team-assignment:
    runs-on: ubuntu-latest
    name: Auto-assign teams based on labels
    if: |
      (github.event_name == 'issues' && github.event.action == 'labeled') ||
      (github.event_name == 'pull_request' && 
       (github.event.action == 'labeled' || github.event.action == 'review_requested')) ||
      (github.event.inputs.action_type == 'assignment' || 
       github.event.inputs.action_type == 'both')
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Assign based on labels
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const issue = context.payload.issue || context.payload.pull_request;
            const labels = issue.labels.map(label => label.name);

            // Team assignment rules - only for specific team notification labels
            const teamAssignments = {
              'area/infrastructure': {
                message: 'ðŸ—ï¸ **Infrastructure Team Notified** - This infrastructure issue has been assigned.'
              },
              'type: docs': {
                message: 'ðŸ“š **Documentation Team Notified** - This docs issue has been assigned.'
              },
              'priority-critical': {
                message: 'ðŸš¨ **Critical Priority** - On-call team has been notified for immediate attention.'
              }
            };

            // Check if we already commented to avoid spam
            const { data: existingComments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number
            });

            // Check for team assignment (skip security - handled by triage workflow)
            for (const label of labels) {
              if (teamAssignments[label]) {
                const hasTeamComment = existingComments.some(comment => 
                  comment.user.login === 'github-actions[bot]' && 
                  comment.body.includes(teamAssignments[label].message.split('**')[1].split('**')[0])
                );

                if (!hasTeamComment) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: teamAssignments[label].message
                  });
                  console.log(`âœ… Added team notification for ${label}`);
                } else {
                  console.log(`â­ï¸ Team comment for ${label} already exists`);
                }
                break; // Only assign to one team
              }
            }

      - name: Community contribution recognition
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        if: github.event_name == 'pull_request' && github.event.action == 'labeled'
        with:
          script: |
            const pr = context.payload.pull_request;
            const author = pr.user.login;
            const labels = pr.labels.map(label => label.name);

            // Only run this for external contributors and only when a specific label is added
            // Check if this is a first-time or external contribution label
            if (!labels.includes('external-contribution')) {
              console.log('â­ï¸ Skipping community recognition - not labeled as external contribution');
              return;
            }

            // Check if we already commented on this PR
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });

            const hasWelcomeComment = comments.some(comment => 
              comment.user.login === 'github-actions[bot]' && 
              comment.body.includes('Thank you for your contribution')
            );

            if (hasWelcomeComment) {
              console.log('â­ï¸ Welcome comment already exists, skipping');
              return;
            }

            try {
              await github.rest.repos.checkCollaborator({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: author
              });
              console.log('â„¹ï¸ User is a collaborator, skipping external contributor message');
            } catch (error) {
              if (error.status === 404) {
                // External contributor
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: 'ðŸŒŸ **Thank you for your contribution!** Welcome to the community - we appreciate external contributions! ðŸ™'
                });
                console.log('âœ… Added welcome comment for external contributor');
              }
            }

  # Triage reporting and metrics
  triage-reporting:
    runs-on: ubuntu-latest
    name: Generate triage metrics
    if: |
      github.event_name == 'schedule' ||
      (github.event.inputs.action_type == 'reporting' || 
       github.event.inputs.action_type == 'both')
    permissions:
      issues: write
      contents: read
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Generate triage report
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const reportType = '${{ github.event.inputs.report_type || 'weekly' }}';
            const daysBack = reportType === 'weekly' ? 7 : reportType === 'monthly' ? 30 : 7;

            console.log(`ðŸ“Š Generating ${reportType} triage report (${daysBack} days)`);

            const now = new Date();
            const startDate = new Date(now.getTime() - daysBack * 24 * 60 * 60 * 1000);
            const startDateStr = startDate.toISOString().split('T')[0];

            // Key metrics queries
            const metrics = {};
            const queries = {
              new_issues: `repo:${context.repo.owner}/${context.repo.repo} is:issue created:>=${startDateStr}`,
              new_prs: `repo:${context.repo.owner}/${context.repo.repo} is:pr created:>=${startDateStr}`,
              closed_issues: `repo:${context.repo.owner}/${context.repo.repo} is:issue closed:>=${startDateStr}`,
              merged_prs: `repo:${context.repo.owner}/${context.repo.repo} is:pr merged:>=${startDateStr}`,
              needs_triage: `repo:${context.repo.owner}/${context.repo.repo} is:open is:issue -label:triaged`,
              high_priority: `repo:${context.repo.owner}/${context.repo.repo} is:open is:issue label:priority-high`,
              security_issues: `repo:${context.repo.owner}/${context.repo.repo} is:open is:issue label:security`,
              stale_items: `repo:${context.repo.owner}/${context.repo.repo} is:open label:stale`
            };

            // Collect metrics
            for (const [key, query] of Object.entries(queries)) {
              try {
                const result = await github.rest.search.issuesAndPullRequests({ q: query });
                metrics[key] = result.data.total_count;
                console.log(`${key}: ${metrics[key]}`);
                // Small delay to respect rate limits
                await new Promise(resolve => setTimeout(resolve, 100));
              } catch (error) {
                console.log(`Error querying ${key}:`, error.message);
                metrics[key] = 'Error';
              }
            }

            // Generate report
            const report = [
              `# ðŸ“Š ${reportType.charAt(0).toUpperCase() + reportType.slice(1)} Triage Report`,
              `*Generated on ${now.toISOString().split('T')[0]} for the last ${daysBack} days*`,
              '',
              '## ðŸ“ˆ Activity Overview',
              `- **New Issues**: ${metrics.new_issues}`,
              `- **New PRs**: ${metrics.new_prs}`,
              `- **Issues Closed**: ${metrics.closed_issues}`,
              `- **PRs Merged**: ${metrics.merged_prs}`,
              '',
              '## ðŸ” Current State',
              `- **Needs Triage**: ${metrics.needs_triage}`,
              `- **High Priority**: ${metrics.high_priority}`,
              `- **Security Issues**: ${metrics.security_issues}`,
              `- **Stale Items**: ${metrics.stale_items}`,
              '',
              '## ðŸŽ¯ Action Items',
              metrics.needs_triage > 10 ? '- âš ï¸ High number of items need triage attention' : '- âœ… Triage queue is manageable',
              metrics.high_priority > 0 ? `- ðŸš¨ ${metrics.high_priority} high priority items need attention` : '- âœ… No high priority items pending',
              metrics.security_issues > 0 ? `- ðŸ”’ ${metrics.security_issues} security issues need review` : '- âœ… No pending security issues',
              '',
              '---',
              '*This report is generated automatically by the triage workflow.*'
            ].join('\n');

            console.log('ðŸ“‹ Generated report:', report);

            // For now, just log the report. In a real setup, you might:
            // - Create an issue with the report
            // - Send to a notification channel
            // - Store as an artifact
            console.log('Report generated successfully!');
